<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Lemur C++ Bitmap Index Library</title>
<style>
body{width:15cm; margin-left:auto;margin-right:auto;}
code{white-space:pre;background: #ccf}
</style>
</head>
<body>
<h1>Lemur C++ Bitmap Index Library</h1>
<p>Documentation by D. Lemire. 2007, 2008 with some help from Owen Kaser and Kamel Aouiche.</p>

<h2>What is this?</h2>

<p>The Lemur C++ Bitmap Index Library is 
an open source software library, together with
command line utilies, to index multidimensional
data sets using word-aligned bitmap indexes. As of June 28, 2008, the utilities only supports
Comma-Separated-Value (CSV) text files.
Both equality queries and range queries are supported.<p>
    
    <p>This library has been used in the preparation of some academic papers including:</p>
    <ul>   
        <li>Owen Kaser, Daniel Lemire, Kamel Aouiche, <a href="http://arxiv.org/abs/0808.2083">Histogram-Aware Sorting for Enhanced Word-Aligned Compression in Bitmap Indexes</a>, DOLAP 2008, 2008.</li>
    </ul>

<h2>Prerequisites</h2>
<p>Building this software requires the GNU GCC 
tool chain. It should work fine with Linux or MacOS X.</p>

<h2>64-bit QDBM</h2>

<p>As of July 2008, building this software requires that you 
have the 64-bit QDBM library. 
<!--Under MacOS, this can be installed
with fink using "fink install qdbm14". It should come with most
Linux distributions.--></p>

<p>Under MacOS, you may need to compile QDBM by hand.
To do so, go to qdbm.sourceforge.net, download the source
tar ball. Then use the following commands:</p>

<pre>
export CC="gcc -arch x86_64 "
./configure --enable-zlib --enable-bzip --enable-iconv --prefix=/opt/qdbm
make mac
make install-mac (as root)
</pre>

<p>If you have a Linux distribution compiled for a 64-bit CPU, 
the process should be easier.</p>

<h2>Building it</h2>

<p>Go into the main directory and type:</p>

<code>
make
./unittesting
</code>

<p>If the unittesting command line utility
does not report any error, then you should proceed
to run the following script:</p>


<code>
./testequalityqueries.sh
</code>



<p>If no error is reported, you can continue.</p>


<h2>Generic Query Syntax</h2>

<p>The query syntax  is quite simple. To seek the
lines in a CSV file for each the third element is
"Dog" and the fourth is "Montreal", simply type:</p>

<code>
2 Dog 3 Montreal
</code>
<p>(Observe that we use the C-like indexing convention
where the first element has index 0.)</p>


<p>If you want to allow one column to have one of several values,
you can simply list all allowed values: (as of August 2008, this is not
supported over bitmap indexes, only for projection indexes)</p>


<code>
2 Dog 2 Cat 3 Montreal
</code>

<p>(This last query could be written as "((dim2 = Dog) or (dim2 = cat)) and (dim3 = Montreal)".)</p>

<p> You can also issue range queries. The ranges are defined in lexicographical order.
For example, Dog is in the interval (Cat,Food). The following query would capture
any row whose second column has a value between Cat and Food inclusively. </p>

<code>
r1 Cat Food
</code>

<p>Of course, you can issue queries on several columns simultaneously. However, you 
you can not allowed to mix equality queries with range queries. Fortunately, simulating
equality queries with range queries is easy: r1 Cat Cat is an equality query.</p>


<p>There is no support for integer or floating-point
values: if you need to work with such data, transform it first to strings such as fixed-length hexadecimal
string: 1 becomes 001, 2 becomes 002 and so on.</p> 

<p>See below for the how to use the syntax together
with the command line tools.</p>

<h2>Querying CSV files (without an index)</h2>

<p>You can query a csv file without any index;
 one such file is provided under
the name "testdata.csv". Here is an
example:</p>
<code>
./querycsv  -v testdata.csv  3 Montreal
</code>
<p>It will then return the matching line numbers
in the CSV file (row IDs). The line numbers start at zero (0).
 Notice that commented out lines
in the CVS file (those beginning with '#') are
not counted. If you omit the "-v" flag, only
the number of matching line and the time used up
is returned.</p>


<h2>Indexing a CSV file</h2>

<p>Creating an index for a given CSV file
can be done with a single command line
where we provide both the file name of the
CVS file, and the desired name of the index
file:</p>

<code>
./indexcsv testdata.csv testindex.bin
</code> 


<p>All dimensions get indexed.</p>

<p>In theory, there is no hard limit on the size
of the CSV file we can index.</p>




<p>Notice that this creates a unary bitmap index.
(If you do not know what this means, you do not need
to worry about it.)
To generate a k-of-N index (composite indexing),
use the "-k" flag as follows:</p>


<code>
./indexcsv  -k 2 testdata.csv testindex.bin
</code> 

<p>Valid and practical values for k include 1, 2, 3, 4.
The higher k, the fewer bitmaps are generated per dimension.
If some of your dimensions have a small cardinality, large values
of k may not make sense, for this reason, the code will
adjust (with warnings) the values of k for some dimensions. 
It will warn you in the error output (stderr and not stdout)
 if some encodings are "corrected". You cannot
disable these warnings.
If you
want to force k-of-N encoding even when it may not make sense,
use the -K flag (notice the upper case).</p>
<p>Here are the rules applied with the -k flag.
Any column with less than or 5 distinct attribute values is limited to 1-of-N
encoding. Any column with less than or 21 distinct attributes values is limited
to the encodings 1-of-N and 2-of-N. Any column having 85 distinct values or less
is limited to the encodings 1-of-N, 2-of-N and 3-of-N.</p>

<p>If many bitmaps are generated in the bitmap index, the performance
of the above commands can be poor. To speed things up, use the
"-s" flag (for sparse) as follows:</p>


<code>
./indexcsv  -k 2 -s testdata.csv testindex.bin
</code> 

<p>The same index will be generated, but possibly much faster.</p>

<h2>Controlling how the bitmaps are allocated</h2>

<p>For indexcsv, you also have an 'a' flag that can be used as -a alpha, -a gray, -a grayall, -a weight, -a weightgray to control how the
 bitmaps are allocated. It is probably only useful with the -k flag for values 2,3,4, the weightgrayall option 
 should work well over sorted CSV files. The default is -a alpha.</p>


<p>The alphabetical bitmap allocation heuristic will start allocating the
bitmaps starting from the first attribute value in alphabetical order.
So Aaron gets 11000, arbre gets 10100 and so on.</p>

<p>The weighted bitmap allocation heuristic will start allocating the
bitmaps starting from the most "heavy" bitmap (the most frequent attribute value).
So the most frequent attribute value gets 11000, the second one 10100, and so on.
It should tend to aggregate the true values in the first few bitmaps.</p>

<p>The gray code ordering takes all of the bitmap codes (11000, 10100, and so on),
then it sorts them by gray code order, and finally it attributes the to first attribute
value (in alphabetical order) to first code and so on.</p>

<h2>Changing the data block size</h2>

<p>The utility indexcsv takes another parameter (-b someintegervalue)
that allows you to specify the data block size in bytes. Larger sizes will
lead to more memory usage, but possibly faster bitmap indexes.
Unless you run out of memory, or have more than a couple
of gigabyte of RAM, you do not need to use this parameter.</p>

<h2>Querying an index file</h2>

<p>We can query an index file just like
we can query a CSV file. For example:</p>
<code>
./querybitmap testindex.bin 3 Montreal
</code>

<p> Without the verbose flag (-v), the command returns the number of matching lines, 
and  the time necessary 
to process the bitmaps (excluding the time to open the external-memory table mapping attribute
values to bitmaps and read the index' metadata). For example, we have</p>
<code>
./querybitmap USCensus1990.data.bin     1 5 2 3 3 1 4 1
1  0.09 
</code>


<p>It means that this query returned one matching line, and the 
core processing of the query took 0.09 second. Notice how we provided
query values for 4 dimensions.   </p>

<p>To get the matching line numbers, simply add the -v flag:</p>

<code>
./querybitmap USCensus1990.data.bin    -v  1 5 2 3 3 1 4 1
</code>


<p>If you want just the matching lines, replace the -v flag by the 
-j flag.</p>


<p>Sometimes, the queries are processes so fast that you cannot tell
how long it took. You can then use the "-r" flag to ask the software
to repeat the query many times:</p>

<code>
./querybitmap USCensus1990.data.bin   -r 100   1 5 2 3 3 1 4 1
1  1.09 
</code>

<p>This last result means that it took 1.09 seconds to process this query
100 times.  Due to system caching, this may yield misleading results.</p>

<p>You can also enter several queries by separating them by "/" as in this example:</p>

<code>
./querybitmap USCensus1990.data.bin       1 5 2 3 3 1 4 1 /  1 5 2 3 3 1 4 2 /  1 5 2 3 3 1 4 3
</code>

<p>You can try the
sparse flag (-s) which should fast if the bitmaps are sparse, however, this flag
is not recommended unless you have sparse indexes with k>1 (such as when you have columns having many, many distinct values):</p>
<code>
./querybitmap testindex.bin -s  3 Montreal
</code>

<p>You can request randomization, where the system will substitute random
attribute values (correct for the dimensions used) for any that you gave.
Use the -R flag, which takes a counter of how many times you want this
done:</p>
<code>
./querybitmap USCensus1990.data.bin -R 200 1 10 2 20 / 1 30
</code>
<p>The first query will be run 200 times, with random values substituted for 10 and 20.
Then the second query will be run 200 times, with random values substituted for 30.
The "number of matching lines" for each query will be an average of the 200 trials.
</p>

<p> The -r and -R flags should not both be used. </p>


<p>Here are some sample results. First index the file testdata.txt (provided
with this software):</p>
<code>
./indexcsv  -k 1 testdata.csv testdata.bin
</code>

<p>Then, the following 3 lines should give you the same result:</p>
<code>
./querybitmap  testdata.bin -v  -s  1 Montreal 0 Daniel
./querybitmap  testdata.bin -v   1 Montreal 0 Daniel
./querycsv testdata.csv 1 Montreal 0 Daniel
</code>

<h2>What if it takes too long to build my index?</h2>

<p>If you are using unary encoding and have several attribute
values, creating the index could be costly. Fortunately,
you can use the '-s' flag (previous discussed) to turn on support for sparse
bitmap indexes:</p>

<code>
./indexcsv  -s -k 1 testdata.csv testindex.bin
</code> 

<p>It is expected that the flag may slow down processing
over dense bitmap indexes such as when the '-k' flag is used
with an integer value above 1.</p>

<h2>What if I want to index only a few dimensions?</h2>

<p> The tool csvextractor can be used to generate a new CSV file
containing only the columns you wish to index. (Alternatively,
the Unix command 'cut' can achieve the same result, maybe faster.) To output
the columns 0 and 2 from testdata.csv to out.csv, run
the following command:</p>

<code>
./csvextractor -i 0 -i 2  testdata.csv out.csv
</code>

<p>You can combine the extraction of the dimension with the
indexing on a single line:</p>
<code>
./csvextractor -i o -i 2  testdata.csv  temp.txt && ./indexcsv  temp.txt temp.bin 
</code>

<p>Note however that when querying the index file, dimension 0 becomes
the first dimension you indexed (and not the first dimension of the original
data file).</p>


<h2>How do I generate a random sample of a CSV file?</h2>

<p>The "sample" utility can be used to sample randomly 
some line in any CSV file (type ./sample for instructions).</p> 

<h2>How can I shuffle the rows of a large CSV file? </h2>
<p>You can achieve this result with the cat, sort and cut unix command,
though you need recent versions:</p>
<code>
 cat -n myfile.csv | sort --random-sort | cut -f 2-
</code>
<h2>Learning a bit more about your indexes</h2>

<p>To learn a bit more about your indexes, there are various 
utilities. The simplest one, dirtywords, simply output
the number of dirty words in a compressed bitmap index:</p>

<code>
./dirtywords testdatabin_k1.bin
</code>


<p> The "dimensionaldirty" utility is similar except that it
outputs statistics on a per dimension basis, and it includes
more statistics including the number of bitmap indexes, the number
of clean words, and so on.</p>
<code>
./dimensionaldirty testdatabin_k1.bin 
</code>
<p>As of December 2007, the format of the output follows this order on each row:</p>

<code>
dirtywords cleanwords distinctnumberofattributevalues numberofbitmapsonthisdimension compressedsizeinwords uncompressedsizeinwords cleanwordscompressed
</code>

<p>Here, cleanwordscompressed should simply be compressedsizeinwords minus dirtywords.</p>

<p> The "analyzebitmap" is another
utility that can output even more verbose information about
your bitmap index.</p>

<h2>Can I see how a bitmap was compressed?</h2>

<p>Using the describeabitmap utility, you can see
how a particular bitmap was compressed using EWAH.
The next command will describe the first bitmap of an index:</p>

<code>
./describeabitmap myindex.bin 0
</code>


<h2>Can I see how the bitmaps were allocated?</h2>

<p>Using the listthecodes utility, you can get a list
of the attribute values with the corresponding
bitmaps (indexes) that are used. You run the command like so:</p>

<code>
./listthecodes myindex.bin 0
</code>


<h2>Working with various word lengths?</h2>


<p>All indexes assume 32-bit words, irrespective
of the CPU. To use 16-bit or 64-bit words, use -B 16 or -B 64
with the indexcsv utility.</p>

<h2>The histograms?</h2>
<p>In order to generate the bitmap indexes, indexcsv first runs through the CSV file
and generates a .histo file containing the histogram of each dimension (or column). In
order to speed up reindexing, this file is left on disk, but can be freely deleted.
If you only want to generate the histogram, you can run indexcsv with the j flag.
</p>


<h2>Can I compare with a simple projection index?</h2>

<p>Of course. Use the -p flag with the indexcsv utility. There
are 4 types of projection indexes, uncompressed, 8, 16, 32. The
8, 16, and 32 projection indexes use 8-bit, 16-bit 32-bit counter-based
run-length encoding. Here is an example:</p>


<code>
./indexcsv -p uncompressed testdata.csv testindex.bin
</code> 
<p>Then, instead of using querybitmap, use the queryprojection utility:</p>
<code>
./queryprojection testindex.bin 3 Montreal
</code>

<h2>Which file contains the bitmap index?</h2>

<p>The indexcsv file will create several files during the
indexing process. For example, beside a binary flat file containing
your bitmaps, such as testindex.bin, it will also generate
a human-readable text file testindex.bin.dim, and a series of QDBM files
(testindex.bin.dim0, testindex.bin.dim1, and so on) (one per column).
The QDBM files contain B-trees and are used to translate your attribute 
values (say value "Dog") to the corresponding bitmap locations in 
the bitmap file (testindex.bin).</p>


<p>The library  first accesses the QDBM files, looks up the bitmap 
locations, and then it proceeds to do the real work over the bitmap 
file (testindex.bin).</p>

<p>You can directly access the content of the B-trees using
QDBM utilities on the QDBM files
(testindex.bin.dim0, testindex.bin.dim1, ...). See the QDBM 
documentation for details.</p>

<p>Conceptually, you could do away with the QDBM files. For example, at 
the C++ level, you could say "take the second and fifth bitmap and load 
them up." </p>

</body>
</html>
